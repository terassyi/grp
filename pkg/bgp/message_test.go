package bgp

import (
	"net"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

var optByte = []byte{0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, // multi protocol extensions
	0x02, 0x02, 0x80, 0x00, // route refresh cisco
	0x02, 0x02, 0x02, 0x00, // route refresh
	0x02, 0x06, 0x41, 0x04, 0x00, 0x00, 0x00, 0x64, // 4-octet AS number
	0x02, 0x06, 0x45, 0x04, 0x00, 0x01, 0x01, 0x01, // additional path
	0x02, 0x1b, 0x49, 0x19, 0x0c, 0x33, 0x64, 0x30, 0x66, 0x66, 0x63, 0x36, 0x61, 0x38, 0x38, 0x61, 0x38, 0x0b, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, // fqdn
	0x02, 0x04, 0x40, 0x02, 0x00, 0x78, // graceful restart
}

func TestPreParse(t *testing.T) {
	tests := []struct {
		name          string
		data          []byte
		packetLengths []int
	}{
		{
			name: "UPDATE 1",
			data: []byte{
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x43, 0x02, 0x00, 0x00, 0x00, 0x28, 0x40, 0x01, 0x01,
				0x02, 0x40, 0x02, 0x0a, 0x02, 0x01, 0x00, 0x1e, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x14, 0x40, 0x03,
				0x04, 0x0a, 0x00, 0x00, 0x09, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x06, 0x00,
				0x1e, 0x0a, 0x00, 0x00, 0x09, 0x15, 0xac, 0x10, 0x00,
			},
			packetLengths: []int{0x43},
		},
		{
			name: "UPDATE 2",
			data: []byte{
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0x00, 0x39, 0x02, 0x00, 0x00, 0x00, 0x1a, 0x40, 0x01, 0x01, 0x00, 0x50, 0x02, 0x00, 0x04, 0x02,
				0x01, 0x00, 0xc8, 0x40, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x02, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00,
				0x00, 0x18, 0x0a, 0x02, 0x00, 0x18, 0x0a, 0x02, 0x04,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x15,
				0x40, 0x01, 0x01, 0x00, 0x50, 0x02, 0x00, 0x06, 0x02, 0x02, 0x00, 0xc8, 0x01, 0x90, 0x40, 0x03,
				0x04, 0x0a, 0x00, 0x00, 0x02, 0x18, 0x0a, 0x04, 0x00,
			},
			packetLengths: []int{0x39, 0x30},
		},
		{
			name: "UPDATE 3",
			data: []byte{
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x3c, 0x02, 0x00, 0x00, 0x00, 0x19, 0x40, 0x01, 0x01,
				0x00, 0x40, 0x02, 0x04, 0x02, 0x01, 0xfe, 0x4c, 0x40, 0x03, 0x04, 0x01, 0x01, 0x01, 0x01, 0x80,
				0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0a, 0x0a, 0x03, 0x18, 0x0a, 0x0a, 0x02, 0x18, 0x0a,
				0x0a, 0x01,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0x00, 0x3a, 0x02, 0x00, 0x00, 0x00, 0x19, 0x40, 0x01, 0x01, 0x02, 0x40, 0x02, 0x04,
				0x02, 0x01, 0xfe, 0x4c, 0x40, 0x03, 0x04, 0x01, 0x01, 0x01, 0x01, 0x80, 0x04, 0x04, 0x00, 0x00,
				0x00, 0x00, 0x1e, 0xac, 0x10, 0x00, 0x00, 0x1e, 0xac, 0x10, 0x00, 0x04,
				0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x37, 0x02, 0x00,
				0x00, 0x00, 0x14, 0x40, 0x01, 0x01, 0x00, 0x40, 0x02, 0x06, 0x02, 0x02, 0xfe, 0x4c, 0xff, 0x14,
				0x40, 0x03, 0x04, 0x01, 0x01, 0x01, 0x01, 0x18, 0x0a, 0x1e, 0x01, 0x18, 0x0a, 0x1e, 0x02, 0x18,
				0x0a, 0x1e, 0x03,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x14, 0x40, 0x01, 0x01, 0x02, 0x40, 0x02,
				0x06, 0x02, 0x02, 0xfe, 0x4c, 0xff, 0x14, 0x40, 0x03, 0x04, 0x01, 0x01, 0x01, 0x01, 0x1e, 0xac,
				0x10, 0x00, 0x08,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x14, 0x40, 0x01, 0x01, 0x02, 0x40, 0x02,
				0x06, 0x02, 0x02, 0xfe, 0x4c, 0xff, 0x14, 0x40, 0x03, 0x04, 0x01, 0x01, 0x01, 0x01, 0x1e, 0xac,
				0x10, 0x00, 0x0c,
			},
			packetLengths: []int{60, 58, 55, 48, 48},
		},
	}
	t.Parallel()
	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			packets, err := preParse(tt.data)
			require.NoError(t, err)
			assert.Equal(t, len(tt.packetLengths), len(packets))
			ls := []int{}
			for _, p := range packets {
				ls = append(ls, len(p))
			}
			assert.Equal(t, tt.packetLengths, ls)
		})
	}
}
func TestParse(t *testing.T) {
	tests := []struct {
		name   string
		data   []byte
		packet *Packet
	}{
		// https://www.cloudshark.org/captures/db5af52c1c80
		{
			name: "OPEN 1",
			data: []byte{
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x2d, 0x01, 0x04, 0x00, 0x1e, 0x00, 0xb4, 0x0a, 0x00,
				0x00, 0x09, 0x10, 0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x80, 0x00, 0x02,
				0x02, 0x02, 0x00,
			},
			packet: &Packet{
				Header: &Header{
					Maker:  [16]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
					Length: 45,
					Type:   OPEN,
				},
			},
		},
		// https://www.cloudshark.org/captures/db5af52c1c80
		{
			name: "KEEPALIVE",
			data: []byte{
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x13, 0x04,
			},
			packet: &Packet{
				Header: &Header{
					Maker:  [16]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
					Length: 19,
					Type:   KEEPALIVE,
				},
			},
		},
		// https://www.cloudshark.org/captures/db5af52c1c80
		{
			name: "UPDATE 1",
			data: []byte{
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x43, 0x02, 0x00, 0x00, 0x00, 0x28, 0x40, 0x01, 0x01,
				0x02, 0x40, 0x02, 0x0a, 0x02, 0x01, 0x00, 0x1e, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x14, 0x40, 0x03,
				0x04, 0x0a, 0x00, 0x00, 0x09, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x06, 0x00,
				0x1e, 0x0a, 0x00, 0x00, 0x09, 0x15, 0xac, 0x10, 0x00,
			},
			packet: &Packet{
				Header: &Header{
					Maker:  [16]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
					Length: 67,
					Type:   UPDATE,
				},
			},
		},
		// https://www.cloudshark.org/captures/ca1b663c5757
		{
			name: "NOTIFICATION",
			data: []byte{
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x17, 0x03, 0x02, 0x02, 0xfe, 0xb0,
			},
			packet: &Packet{
				Header: &Header{
					Maker:  [16]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
					Length: 23,
					Type:   NOTIFICATION,
				},
			},
		},
	}
	t.Parallel()
	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			p, err := Parse(tt.data)
			require.NoError(t, err)
			assert.Equal(t, tt.packet.Header, p.Header)
			assert.Equal(t, tt.packet.Header.Type, p.Message.Type())
		})
	}
}

func TestPacketDecode(t *testing.T) {
	tests := []struct {
		name string
		data []byte
	}{
		{
			name: "DATA 1",
			data: []byte{
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x2d, 0x01, 0x04, 0x00, 0x1e, 0x00, 0xb4, 0x0a, 0x00,
				0x00, 0x09, 0x10, 0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x80, 0x00, 0x02,
				0x02, 0x02, 0x00},
		},
		{

			name: "DATA 2",
			data: []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x13, 0x04},
		},
		{
			name: "DATA 3",
			data: []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x43, 0x02, 0x00, 0x00, 0x00, 0x28, 0x40, 0x01, 0x01,
				0x02, 0x40, 0x02, 0x0a, 0x02, 0x01, 0x00, 0x1e, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x14, 0x40, 0x03,
				0x04, 0x0a, 0x00, 0x00, 0x09, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x06, 0x00,
				0x1e, 0x0a, 0x00, 0x00, 0x09, 0x15, 0xac, 0x10, 0x00},
		},
		{
			name: "DATA 4",
			data: []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x17, 0x03, 0x02, 0x02, 0xfe, 0xb0},
		},
	}
	t.Parallel()
	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			p, err := Parse(tt.data)
			require.NoError(t, err)
			data, err := p.Decode()
			require.NoError(t, err)
			assert.Equal(t, tt.data, data)
		})
	}
}

func TestParseOpenMsg(t *testing.T) {
	tests := []struct {
		name string
		data []byte
		exp  *Open
	}{
		{
			name: "OPEN 1",
			data: []byte{0x04, 0xfe, 0xb0, 0x00, 0xb4, 0x0a, 0x14, 0x03, 0x01, 0x10, 0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x80, 0x00, 0x02, 0x02, 0x02, 0x00},
			exp: &Open{
				Version:    4,
				AS:         65200,
				HoldTime:   180,
				Identifier: net.ParseIP("10.20.3.1").To4(),
				OptParmLen: 16,
				Options: []*Option{
					{Type: ParameterType(2), Length: 6, Value: []byte{0x01, 0x04, 0x00, 0x01, 0x00, 0x01}},
					{Type: ParameterType(2), Length: 2, Value: []byte{0x80, 0x00}},
					{Type: ParameterType(2), Length: 2, Value: []byte{0x02, 0x00}},
				},
			},
		},
		{
			name: "OPEN 2",
			data: []byte{0x04, 0x00, 0x1e, 0x00, 0xb4, 0x0a, 0x00, 0x00, 0x09, 0x10, 0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x80, 0x00, 0x02, 0x02, 0x02, 0x00},
			exp: &Open{
				Version:    4,
				AS:         30,
				HoldTime:   180,
				Identifier: net.ParseIP("10.0.0.9").To4(),
				OptParmLen: 16,
				Options: []*Option{
					{Type: ParameterType(2), Length: 6, Value: []byte{0x01, 0x04, 0x00, 0x01, 0x00, 0x01}},
					{Type: ParameterType(2), Length: 2, Value: []byte{0x80, 0x00}},
					{Type: ParameterType(2), Length: 2, Value: []byte{0x02, 0x00}},
				},
			},
		},
	}
	t.Parallel()
	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			op, err := ParseOpenMsg(tt.data)
			require.NoError(t, err)
			assert.Equal(t, tt.exp.Version, op.Version)
			assert.Equal(t, tt.exp.AS, op.AS)
			assert.Equal(t, tt.exp.HoldTime, op.HoldTime)
			assert.Equal(t, tt.exp.Identifier, op.Identifier)
			assert.Equal(t, tt.exp.OptParmLen, op.OptParmLen)
			assert.Equal(t, tt.exp.Options, op.Options)
		})
	}
}

func TestParseUpdateMsg(t *testing.T) {
	tests := []struct {
		name string
		data []byte
		exp  *Update
	}{
		{
			name: "UPDATE 1",
			data: []byte{
				0x00, 0x00, 0x00, 0x28, 0x40, 0x01, 0x01,
				0x02, 0x40, 0x02, 0x0a, 0x02, 0x01, 0x00, 0x1e, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x14, 0x40, 0x03,
				0x04, 0x0a, 0x00, 0x00, 0x09, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x06, 0x00,
				0x1e, 0x0a, 0x00, 0x00, 0x09, 0x15, 0xac, 0x10, 0x00,
			},
			exp: &Update{
				WithdrawnRoutesLen: 0,
				WithdrawnRoutes:    []*Prefix{},
				TotalPathAttrLen:   40,
				PathAttrs: []PathAttr{
					&Origin{
						pathAttr: &pathAttr{flags: PATH_ATTR_FLAG_TRANSITIVE, typ: ORIGIN},
						length:   1,
						value:    ORIGIN_INCOMPLETE,
					},
					&ASPath{
						pathAttr: &pathAttr{flags: PATH_ATTR_FLAG_TRANSITIVE, typ: AS_PATH},
						length:   10,
						Segments: []*ASPathSegment{
							{Type: SEG_TYPE_AS_SEQUENCE, Length: 1, AS2: []uint16{30}},
							{Type: SEG_TYPE_AS_SET, Length: 2, AS2: []uint16{10, 20}},
						},
					},
					&NextHop{
						pathAttr: &pathAttr{flags: PATH_ATTR_FLAG_TRANSITIVE, typ: NEXT_HOP},
						length:   4,
						next:     net.ParseIP("10.0.0.9").To4(),
					},
					&MultiExitDisc{
						pathAttr:      &pathAttr{flags: PATH_ATTR_FLAG_OPTIONAL, typ: MULTI_EXIT_DISC},
						length:        4,
						discriminator: 0,
					},
					&Aggregator{
						pathAttr: &pathAttr{flags: PATH_ATTR_FLAG_OPTIONAL | PATH_ATTR_FLAG_TRANSITIVE, typ: AGGREGATOR},
						length:   6,
						AS:       30,
						Address:  net.ParseIP("10.0.0.9").To4(),
					},
				},
				NetworkLayerReachabilityInfo: []*Prefix{
					{Length: 21, Prefix: net.ParseIP("172.16.0.0").To4()},
				},
			},
		},
		{
			name: "UPDATE 2",
			data: []byte{
				0x00, 0x00, 0x00, 0x00,
			},
			exp: &Update{
				WithdrawnRoutesLen:           0,
				WithdrawnRoutes:              []*Prefix{},
				TotalPathAttrLen:             0,
				PathAttrs:                    []PathAttr{},
				NetworkLayerReachabilityInfo: []*Prefix{},
			},
		},
		{
			name: "UPDATE 3",
			data: []byte{
				0x00, 0x00, 0x00, 0x07, 0x90, 0x0f, 0x00, 0x03, 0x00, 0x01, 0x04,
			},
			exp: &Update{
				WithdrawnRoutesLen: 0,
				WithdrawnRoutes:    []*Prefix{},
				TotalPathAttrLen:   7,
				PathAttrs: []PathAttr{
					&UnimplementedPathAttr{
						pathAttr: &pathAttr{flags: PATH_ATTR_FLAG_OPTIONAL | PATH_ATTR_FLAG_EXTENDED, typ: PathAttrType(15)},
						length:   3,
						data:     []byte{0x00, 0x01, 0x04},
					},
				},
				NetworkLayerReachabilityInfo: []*Prefix{},
			},
		},
		{
			name: "UPDATE 4",
			data: []byte{
				0x00, 0x00, 0x00, 0x1a, 0x40, 0x01, 0x01, 0x00, 0x50, 0x02, 0x00, 0x04, 0x02,
				0x01, 0x00, 0xc8, 0x40, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x02, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00,
				0x00, 0x18, 0x0a, 0x02, 0x00, 0x18, 0x0a, 0x02, 0x04,
			},
			exp: &Update{
				WithdrawnRoutesLen: 0,
				WithdrawnRoutes:    []*Prefix{},
				TotalPathAttrLen:   26,
				PathAttrs: []PathAttr{
					&Origin{
						pathAttr: &pathAttr{flags: PATH_ATTR_FLAG_TRANSITIVE, typ: ORIGIN},
						length:   1,
						value:    ORIGIN_IGP,
					},
					&ASPath{
						pathAttr: &pathAttr{flags: PATH_ATTR_FLAG_TRANSITIVE | PATH_ATTR_FLAG_EXTENDED, typ: AS_PATH},
						length:   4,
						Segments: []*ASPathSegment{
							{Type: SEG_TYPE_AS_SEQUENCE, Length: 1, AS2: []uint16{200}},
						},
					},
					&NextHop{
						pathAttr: &pathAttr{flags: PATH_ATTR_FLAG_TRANSITIVE, typ: NEXT_HOP},
						length:   4,
						next:     net.ParseIP("10.0.0.2").To4(),
					},
					&MultiExitDisc{
						pathAttr:      &pathAttr{flags: PATH_ATTR_FLAG_OPTIONAL, typ: MULTI_EXIT_DISC},
						length:        4,
						discriminator: 0,
					},
				},
				NetworkLayerReachabilityInfo: []*Prefix{},
			},
		},
		{
			name: "UPDATE 5",
			data: []byte{
				0x00, 0x08, 0x18, 0x0a, 0x00, 0x00, 0x18, 0x0a, 0x05, 0x00, 0x00, 0x00,
			},
			exp: &Update{
				WithdrawnRoutesLen: 8,
				WithdrawnRoutes: []*Prefix{
					PrefixFromString("10.0.0.0/24"),
					PrefixFromString("10.5.0.0/24"),
				},
			},
		},
	}
	t.Parallel()
	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			update, err := ParseUpdateMsg(tt.data)
			require.NoError(t, err)
			assert.Equal(t, tt.exp.Type(), UPDATE)
			assert.Equal(t, tt.exp.WithdrawnRoutesLen, update.WithdrawnRoutesLen)
			for i, wr := range tt.exp.WithdrawnRoutes {
				assert.Equal(t, wr, update.WithdrawnRoutes[i])
			}
			assert.Equal(t, tt.exp.TotalPathAttrLen, update.TotalPathAttrLen)
			for i, attr := range tt.exp.PathAttrs {
				assert.Equal(t, attr, update.PathAttrs[i])
			}
			for i, nlri := range tt.exp.NetworkLayerReachabilityInfo {
				assert.Equal(t, nlri, update.NetworkLayerReachabilityInfo[i])
			}
		})
	}
}

func TestParseNotificationMsg(t *testing.T) {
	tests := []struct {
		name string
		data []byte
		exp  *Notification
	}{
		// https://www.cloudshark.org/captures/ca1b663c5757
		{name: "NOTIFICATION 1", data: []byte{0x02, 0x02, 0xfe, 0xb0}, exp: &Notification{ErrorCode: &ErrorCode{Code: OPEN_MESSAGE_ERROR, Subcode: BAD_PEER_AS}, Data: []byte{0xfe, 0xb0}}},
	}
	t.Parallel()
	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			notif, err := ParseNotificationMsg(tt.data)
			require.NoError(t, err)
			assert.Equal(t, tt.exp.ErrorCode.Code, notif.ErrorCode.Code)
		})
	}
}

func TestOpen_Decode(t *testing.T) {
	tests := []struct {
		name string
		data []byte
	}{
		{
			name: "DATA 1",
			data: []byte{0x04, 0xfe, 0xb0, 0x00, 0xb4, 0x0a, 0x14, 0x03, 0x01, 0x10, 0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x80, 0x00, 0x02, 0x02, 0x02, 0x00},
		},
		{
			name: "DATA 2",
			data: []byte{0x04, 0x00, 0x1e, 0x00, 0xb4, 0x0a, 0x00, 0x00, 0x09, 0x10, 0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x80, 0x00, 0x02, 0x02, 0x02, 0x00},
		},
	}
	t.Parallel()
	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			msg, err := ParseOpenMsg(tt.data)
			require.NoError(t, err)
			data, err := msg.Decode(len(tt.data))
			require.NoError(t, err)
			assert.Equal(t, tt.data, data)
		})
	}
}

func TestUpdate_Decode(t *testing.T) {
	tests := []struct {
		name string
		data []byte
	}{
		{
			name: "DATA 1",
			data: []byte{0x00, 0x00, 0x00, 0x28, 0x40, 0x01, 0x01,
				0x02, 0x40, 0x02, 0x0a, 0x02, 0x01, 0x00, 0x1e, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x14, 0x40, 0x03,
				0x04, 0x0a, 0x00, 0x00, 0x09, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x06, 0x00,
				0x1e, 0x0a, 0x00, 0x00, 0x09, 0x15, 0xac, 0x10, 0x00},
		},
		{
			name: "DATA 2",
			data: []byte{0x00, 0x00, 0x00, 0x19, 0x40, 0x01, 0x01,
				0x00, 0x40, 0x02, 0x04, 0x02, 0x01, 0xfe, 0x4c, 0x40, 0x03, 0x04, 0x01, 0x01, 0x01, 0x01, 0x80,
				0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0a, 0x0a, 0x03, 0x18, 0x0a, 0x0a, 0x02, 0x18, 0x0a, 0x0a, 0x01},
		},
	}
	t.Parallel()
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			msg, err := ParseUpdateMsg(tt.data)
			require.NoError(t, err)
			data, err := msg.Decode(len(tt.data))
			require.NoError(t, err)
			assert.Equal(t, tt.data, data)
		})
	}
}

func TestUpdateValidate(t *testing.T) {
	tests := []struct {
		name   string
		data   []byte
		expErr *ErrorCode
	}{
		{
			name: "VALID 1",
			data: []byte{
				0x00, 0x00, 0x00, 0x28, 0x40, 0x01, 0x01,
				0x02, 0x40, 0x02, 0x0a, 0x02, 0x01, 0x00, 0x1e, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x14, 0x40, 0x03,
				0x04, 0x0a, 0x00, 0x00, 0x09, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x06, 0x00,
				0x1e, 0x0a, 0x00, 0x00, 0x09, 0x15, 0xac, 0x10, 0x00,
			},
			expErr: nil,
		},
		{
			name: "VALID 2",
			data: []byte{
				0x00, 0x00, 0x00, 0x00,
			},
			expErr: nil,
		},
		{
			name: "VALID 3",
			data: []byte{
				0x00, 0x00, 0x00, 0x1a, 0x40, 0x01, 0x01, 0x00, 0x50, 0x02, 0x00, 0x04, 0x02,
				0x01, 0x00, 0xc8, 0x40, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x02, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00,
				0x00, 0x18, 0x0a, 0x02, 0x00, 0x18, 0x0a, 0x02, 0x04,
			},
			expErr: nil,
		},
		{
			name: "VALID 4",
			data: []byte{
				0x00, 0x00, 0x00, 0x1a, 0x40, 0x01, 0x01, 0x00, 0x50, 0x02, 0x00, 0x04, 0x02,
				0x01, 0x00, 0xc8, 0x40, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x02, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00,
				0x00, 0x18, 0x0a, 0x02, 0x00, 0x18, 0x0a, 0x02, 0x04,
				// 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				// 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x15,
				// 0x40, 0x01, 0x01, 0x00, 0x50, 0x02, 0x00, 0x06, 0x02, 0x02, 0x00, 0xc8, 0x01, 0x90, 0x40, 0x03,
				// 0x04, 0x0a, 0x00, 0x00, 0x02, 0x18, 0x0a, 0x04, 0x00,
			},
			expErr: nil,
		},
		{
			name: "VALID 4",
			data: []byte{
				0x00, 0x00, 0x00, 0x15,
				0x40, 0x01, 0x01, 0x00, 0x50, 0x02, 0x00, 0x06, 0x02, 0x02, 0x00, 0xc8, 0x01, 0x90, 0x40, 0x03,
				0x04, 0x0a, 0x00, 0x00, 0x02, 0x18, 0x0a, 0x04, 0x00,
			},
			expErr: nil,
		},
		{
			name: "INVALID 1",
			data: []byte{
				0x00, 0x00, 0x00, 0x07, 0x90, 0x0f, 0x00, 0x03, 0x00, 0x01, 0x04,
			},
			expErr: &ErrorCode{Code: UPDATE_MESSAGE_ERROR, Subcode: MISSING_WELL_KNOWN_ATTRIBUTE},
		},
	}
	t.Parallel()
	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			update, err := ParseUpdateMsg(tt.data)
			require.NoError(t, err)
			_, errC := update.Validate(uint16(len(tt.data)))
			if tt.expErr != nil {
				require.Error(t, errC)
			} else {
				if errC != nil {
					t.Fatal(err)
				}
			}
		})
	}

}

func TestNotification_Decode(t *testing.T) {
	tests := []struct {
		name string
		data []byte
	}{
		{
			name: "DATA 1",
			data: []byte{0x02, 0x02, 0xfe, 0xb0},
		},
	}
	t.Parallel()
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			msg, err := ParseNotificationMsg(tt.data)
			require.NoError(t, err)
			data, err := msg.Decode(len(tt.data))
			require.NoError(t, err)
			assert.Equal(t, tt.data, data)
		})
	}
}
