// generated by deep-copy --type Path ./pkg/bgp; DO NOT EDIT.

package bgp

import (
	"github.com/vishvananda/netlink"
	"net"
)

// DeepCopy generates a deep copy of Path
func (o Path) DeepCopy() Path {
	var cp Path = o
	if o.info != nil {
		cp.info = new(peerInfo)
		*cp.info = *o.info
		if o.info.neighbor != nil {
			cp.info.neighbor = new(neighbor)
			*cp.info.neighbor = *o.info.neighbor
			if o.info.neighbor.addr != nil {
				cp.info.neighbor.addr = make([]byte, len(o.info.neighbor.addr))
				copy(cp.info.neighbor.addr, o.info.neighbor.addr)
			}
			if o.info.neighbor.routerId != nil {
				cp.info.neighbor.routerId = make([]byte, len(o.info.neighbor.routerId))
				copy(cp.info.neighbor.routerId, o.info.neighbor.routerId)
			}
			if o.info.neighbor.capabilities != nil {
				cp.info.neighbor.capabilities = make([]Capability, len(o.info.neighbor.capabilities))
				copy(cp.info.neighbor.capabilities, o.info.neighbor.capabilities)
			}
		}
		if o.info.addr != nil {
			cp.info.addr = make([]byte, len(o.info.addr))
			copy(cp.info.addr, o.info.addr)
		}
		if o.info.routerId != nil {
			cp.info.routerId = make([]byte, len(o.info.routerId))
			copy(cp.info.routerId, o.info.routerId)
		}
	}
	if o.routes != nil {
		cp.routes = make([]netlink.Route, len(o.routes))
		copy(cp.routes, o.routes)
		for i2 := range o.routes {
			if o.routes[i2].Dst != nil {
				cp.routes[i2].Dst = new(net.IPNet)
				*cp.routes[i2].Dst = *o.routes[i2].Dst
				if o.routes[i2].Dst.IP != nil {
					cp.routes[i2].Dst.IP = make([]byte, len(o.routes[i2].Dst.IP))
					copy(cp.routes[i2].Dst.IP, o.routes[i2].Dst.IP)
				}
				if o.routes[i2].Dst.Mask != nil {
					cp.routes[i2].Dst.Mask = make([]byte, len(o.routes[i2].Dst.Mask))
					copy(cp.routes[i2].Dst.Mask, o.routes[i2].Dst.Mask)
				}
			}
			if o.routes[i2].Src != nil {
				cp.routes[i2].Src = make([]byte, len(o.routes[i2].Src))
				copy(cp.routes[i2].Src, o.routes[i2].Src)
			}
			if o.routes[i2].Gw != nil {
				cp.routes[i2].Gw = make([]byte, len(o.routes[i2].Gw))
				copy(cp.routes[i2].Gw, o.routes[i2].Gw)
			}
			if o.routes[i2].MultiPath != nil {
				cp.routes[i2].MultiPath = make([]*netlink.NexthopInfo, len(o.routes[i2].MultiPath))
				copy(cp.routes[i2].MultiPath, o.routes[i2].MultiPath)
				for i4 := range o.routes[i2].MultiPath {
					if o.routes[i2].MultiPath[i4] != nil {
						cp.routes[i2].MultiPath[i4] = new(netlink.NexthopInfo)
						*cp.routes[i2].MultiPath[i4] = *o.routes[i2].MultiPath[i4]
						if o.routes[i2].MultiPath[i4].Gw != nil {
							cp.routes[i2].MultiPath[i4].Gw = make([]byte, len(o.routes[i2].MultiPath[i4].Gw))
							copy(cp.routes[i2].MultiPath[i4].Gw, o.routes[i2].MultiPath[i4].Gw)
						}
					}
				}
			}
			if o.routes[i2].MPLSDst != nil {
				cp.routes[i2].MPLSDst = new(int)
				*cp.routes[i2].MPLSDst = *o.routes[i2].MPLSDst
			}
		}
	}
	if o.nextHop != nil {
		cp.nextHop = make([]byte, len(o.nextHop))
		copy(cp.nextHop, o.nextHop)
	}
	if o.origin.pathAttr != nil {
		cp.origin.pathAttr = new(pathAttr)
		*cp.origin.pathAttr = *o.origin.pathAttr
	}
	if o.asPath.pathAttr != nil {
		cp.asPath.pathAttr = new(pathAttr)
		*cp.asPath.pathAttr = *o.asPath.pathAttr
	}
	if o.asPath.Segments != nil {
		cp.asPath.Segments = make([]*ASPathSegment, len(o.asPath.Segments))
		copy(cp.asPath.Segments, o.asPath.Segments)
		for i3 := range o.asPath.Segments {
			if o.asPath.Segments[i3] != nil {
				cp.asPath.Segments[i3] = new(ASPathSegment)
				*cp.asPath.Segments[i3] = *o.asPath.Segments[i3]
				if o.asPath.Segments[i3].AS2 != nil {
					cp.asPath.Segments[i3].AS2 = make([]uint16, len(o.asPath.Segments[i3].AS2))
					copy(cp.asPath.Segments[i3].AS2, o.asPath.Segments[i3].AS2)
				}
			}
		}
	}
	if o.nlri != nil {
		cp.nlri = new(Prefix)
		*cp.nlri = *o.nlri
		if o.nlri.Prefix != nil {
			cp.nlri.Prefix = make([]byte, len(o.nlri.Prefix))
			copy(cp.nlri.Prefix, o.nlri.Prefix)
		}
	}
	if o.recognizedAttrs != nil {
		cp.recognizedAttrs = make([]PathAttr, len(o.recognizedAttrs))
		copy(cp.recognizedAttrs, o.recognizedAttrs)
	}
	return cp
}
